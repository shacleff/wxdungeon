// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.  

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        alphaThreshold: { value: 0.5 }
        outlineSize: {value: 0}
        textureSizeWidth: {value: 1}
        textureSizeHeight: {value: 1}
}%


CCProgram vs %{
  precision highp float;

  #include <cc-global>
  #include <cc-local>

  in vec3 a_position;
  in vec4 a_color;
  out vec4 v_color;

  #if USE_TEXTURE
  in vec2 a_uv0;
  out vec2 v_uv0;
  #endif

  void main () {
    vec4 pos = vec4(a_position, 1);

    #if CC_USE_MODEL
    pos = cc_matViewProj * cc_matWorld * pos;
    #else
    pos = cc_matViewProj * pos;
    #endif

    #if USE_TEXTURE
    v_uv0 = a_uv0;
    #endif

    v_color = a_color;

    gl_Position = pos;
  }
}%


CCProgram fs %{
  precision highp float;
  
  #include <alpha-test>
  #include <texture>

  in vec4 v_color;

  #if USE_TEXTURE
  in vec2 v_uv0;
  uniform sampler2D texture;
  #endif
  uniform OutLine{
    float outlineSize;
    float textureSizeWidth;
    float textureSizeHeight;
  };
  // 判断在这个角度上距离为outlineSize那一点是不是透明
  int getIsStrokeWithAngel(float angel)
  {
    int stroke = 0;
    vec2 textureSize = vec2(textureSizeWidth,textureSizeHeight);
    float rad = angel * 0.01745329252; // 这个浮点数是 pi / 180，角度转弧度
    vec2 unit = 1.0 / textureSize.xy;//单位坐标
    vec2 offset = vec2(outlineSize * cos(rad) * unit.x, outlineSize * sin(rad) * unit.y); //偏移量
    float a = texture2D(texture, v_uv0 + offset).a;
    if (a >= 0.5)// 我把alpha值大于0.5都视为不透明，小于0.5都视为透明
    {
        stroke = 1;
    }
    return stroke;
  }
  void main () {
    vec4 myC = texture2D(texture, v_uv0); // 正在处理的这个像素点的颜色
    if (myC.a >= 0.5) // 不透明，不管，直接返回
    {
        gl_FragColor = v_color * myC;
        return;
    }
    // 这里肯定有朋友会问，一个for循环就搞定啦，怎么这么麻烦！其实我一开始也是用for的，但后来在安卓某些机型（如小米4）会直接崩溃，查找资料发现OpenGL es并不是很支持循环，while和for都不要用
    int strokeCount = 0;
    strokeCount += getIsStrokeWithAngel(0.0);
    strokeCount += getIsStrokeWithAngel(30.0);
    strokeCount += getIsStrokeWithAngel(60.0);
    strokeCount += getIsStrokeWithAngel(90.0);
    strokeCount += getIsStrokeWithAngel(120.0);
    strokeCount += getIsStrokeWithAngel(150.0);
    strokeCount += getIsStrokeWithAngel(180.0);
    strokeCount += getIsStrokeWithAngel(210.0);
    strokeCount += getIsStrokeWithAngel(240.0);
    strokeCount += getIsStrokeWithAngel(270.0);
    strokeCount += getIsStrokeWithAngel(300.0);
    strokeCount += getIsStrokeWithAngel(330.0);

    if (strokeCount > 0) // 四周围至少有一个点是不透明的，这个点要设成描边颜色
    {
        myC.rgb = vec3(1,1,1);
        myC.a = 1.0;
    }

    gl_FragColor = v_color * myC;
  }
}%
